<?php

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use App\Models\Item;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\DB;

class ProductController extends Controller
{
    /*
     * Retrieve all products.
     *
     * @return \Illuminate\Http\JsonResponse
     */

    public function products()
    {
        // Get pagination parameters
        $page = request()->input('page', 1);
        $perPage = request()->input('per_page', 10);
        $perPage = min($perPage, 100); // Limit max per page to prevent memory issues
        
        // Create cache key based on pagination
        $cacheKey = "products_page_{$page}_per_page_{$perPage}";
        $cacheTime = 60; // Cache for 60 minutes
        
        // Use cache to store the expensive query results
        $result = Cache::remember($cacheKey, $cacheTime, function () use ($page, $perPage) {
            // Use Eloquent with proper relationships for better performance
            $products = Item::with(['itemPrices' => function ($query) {
                    // Only load active prices and limit fields
                    $query->select('item_id', 'price_list_id', 'price_list_name', 'uom', 'list_price', 'start_date_active')
                          ->where('start_date_active', '<=', now())
                          ->whereNull('end_date_active');
                }])
                ->select('id', 'inventory_item_id', 'item_code', 'item_description', 
                        'primary_uom_code', 'secondary_uom_code', 'major_category', 
                        'minor_category', 'sub_minor_category', 'created_at', 'updated_at')
                ->orderBy('id')
                ->paginate($perPage, ['*'], 'page', $page);
            
            // Transform the data to match the expected format
            $transformedData = $products->getCollection()->flatMap(function ($item) {
                if ($item->itemPrices->isEmpty()) {
                    // If no prices, return item without price info
                    return [[
                        'id' => $item->id,
                        'inventory_item_id' => $item->inventory_item_id,
                        'item_code' => $item->item_code,
                        'item_description' => $item->item_description,
                        'primary_uom_code' => $item->primary_uom_code,
                        'secondary_uom_code' => $item->secondary_uom_code,
                        'major_category' => $item->major_category,
                        'minor_category' => $item->minor_category,
                        'sub_minor_category' => $item->sub_minor_category,
                        'created_at' => $item->created_at,
                        'updated_at' => $item->updated_at,
                        'price_list_id' => null,
                        'price_list_name' => null,
                        'uom' => null,
                        'list_price' => null,
                        'start_date_active' => null,
                    ]];
                }
                
                // Return one record per price
                return $item->itemPrices->map(function ($price) use ($item) {
                    return [
                        'id' => $item->id,
                        'inventory_item_id' => $item->inventory_item_id,
                        'item_code' => $item->item_code,
                        'item_description' => $item->item_description,
                        'primary_uom_code' => $item->primary_uom_code,
                        'secondary_uom_code' => $item->secondary_uom_code,
                        'major_category' => $item->major_category,
                        'minor_category' => $item->minor_category,
                        'sub_minor_category' => $item->sub_minor_category,
                        'created_at' => $item->created_at,
                        'updated_at' => $item->updated_at,
                        'price_list_id' => $price->price_list_id,
                        'price_list_name' => $price->price_list_name,
                        'uom' => $price->uom,
                        'list_price' => $price->list_price,
                        'start_date_active' => $price->start_date_active,
                    ];
                });
            });
            
            return [
                'data' => $transformedData,
                'pagination' => [
                    'total' => $products->total(),
                    'count' => $transformedData->count(),
                    'per_page' => $products->perPage(),
                    'current_page' => $products->currentPage(),
                    'total_pages' => $products->lastPage(),
                    'next_page_url' => $products->hasMorePages(),
                    'prev_page_url' => $products->currentPage() > 1,
                ],
            ];
        });
        
        return response()->json([
            'success' => true,
            'status' => 200,
            'message' => 'Products retrieved successfully',
            'data' => $result['data'],
            'pagination' => $result['pagination'],
        ], 200);
    }
    
    /**
     * Retrieve a specific product's details.
     */
    public function getProduct(Request $request): JsonResponse
    {
        // Validate the request to ensure 'inventory_item_id' is provided and exists
        $validated = $request->validate([
            'inventory_item_id' => 'required|exists:items,inventory_item_id',
        ]);

        $cacheKey = 'product_details_' . $validated['inventory_item_id'];
        $cacheTime = 60;

        // Attempt to retrieve data from cache
        $product = Cache::remember($cacheKey, $cacheTime, function () use ($validated) {
            return Item::with(['itemPrice'])
                ->where('inventory_item_id', $validated['inventory_item_id'])
                ->first();
        });

        if (! $product) {
            return response()->json([
                'success' => false,
                'status' => 404,
                'message' => 'Product not found',
            ], 404);
        }

        // Map the product details manually
        $mappedProduct = [
            'inventory_item_id' => $product->inventory_item_id,
            'item_code' => $product->item_code,
            'item_description' => $product->item_description,
            'primary_uom_code' => $product->primary_uom_code,
            'secondary_uom_code' => $product->secondary_uom_code,
            'major_category' => $product->major_category,
            'minor_category' => $product->minor_category,
            'sub_minor_category' => $product->sub_minor_category,
        ];

        return response()->json([
            'success' => true,
            'status' => 200,
            'message' => 'Product details retrieved successfully',
            'data' => $mappedProduct,
        ], 200);
    }

    /**
     * Search for products by inventory_item_id, item_code, or item_description using LIKE and map results.
     */
    public function searchProduct(Request $request): JsonResponse
    {
        // Validate the request to ensure 'searchTerm' is provided
        $validated = $request->validate([
            'searchTerm' => 'required|string',
        ]);

        // Extract the search term and break it into individual words
        $searchTerm = $validated['searchTerm'];
        $terms = explode(' ', $searchTerm);

        // Generate a cache key based on the search term
        $cacheKey = 'search_products_' . md5($searchTerm);
        $cacheTime = 60; // Cache time in minutes

        // Attempt to retrieve data from cache
        $products = Cache::remember($cacheKey, $cacheTime, function () use ($terms, $searchTerm) {
            return Item::with(['itemPrices' => function ($query) {
                    // Only load active prices and limit fields for better performance
                    $query->select('item_id', 'price_list_id', 'price_list_name', 'uom', 'list_price', 'start_date_active', 'end_date_active')
                          ->where('start_date_active', '<=', now());
                }])
                ->select('id', 'inventory_item_id', 'item_code', 'item_description', 
                        'primary_uom_code', 'secondary_uom_code', 'major_category', 
                        'minor_category', 'sub_minor_category', 'created_at', 'updated_at')
                ->where(function ($query) use ($terms) {
                    foreach ($terms as $term) {
                        // Ensure each term is present in either item_description or item_code
                        $query->where(function ($q) use ($term) {
                            $q->where('item_description', 'like', '%' . $term . '%')
                                ->orWhere('item_code', 'like', '%' . $term . '%');
                        });
                    }
                })
                ->orderByRaw("
                        CASE
                            WHEN item_description LIKE ? OR item_code LIKE ? THEN 1                -- Exact match
                            WHEN item_description LIKE ? OR item_code LIKE ? THEN 2                -- Terms in order
                            WHEN item_description LIKE ? OR item_code LIKE ? THEN 3                -- Terms in reverse order
                            ELSE 4
                        END
                    ", [
                    "%$searchTerm%",
                    "%$searchTerm%",                     // Exact full-term match in either column
                    "%" . implode('%', $terms) . "%",
                    "%" . implode('%', $terms) . "%",    // Terms in order
                    "%" . implode('%', array_reverse($terms)) . "%",
                    "%" . implode('%', array_reverse($terms)) . "%" // Terms in reverse order
                ])
                ->limit(50) // Limit search results for better performance
                ->get();
        });

        // Map the results to the desired format
        $mappedProducts = $products->flatMap(function ($item) {
            return $item->itemPrices->map(function ($price) use ($item) {
                return [
                    'id' => $item->id, // Adding the id of the item (matches 'items.id')
                    'inventory_item_id' => $item->inventory_item_id,
                    'item_code' => $item->item_code,
                    'item_description' => $item->item_description,
                    'primary_uom_code' => $item->primary_uom_code,
                    'secondary_uom_code' => $item->secondary_uom_code,
                    'major_category' => $item->major_category,
                    'minor_category' => $item->minor_category,
                    'sub_minor_category' => $item->sub_minor_category,
                    'created_at' => $item->created_at, // Include 'created_at'
                    'updated_at' => $item->updated_at, // Include 'updated_at'
                    'price_list_id' => $price->price_list_id, // Adding price list id
                    'price_list_name' => $price->price_list_name,
                    'uom' => $price->uom,
                    'list_price' => $price->list_price, // Matching 'list_price' from item_prices
                    'start_date_active' => $price->start_date_active,
                    'end_date_active' => $price->end_date_active,
                ];
            });
        });


        // Return the results in JSON format
        return response()->json([
            'success' => true,
            'status' => 200,
            'message' => 'Products retrieved successfully.',
            'data' => $mappedProducts,
        ], 200);
    }

    /**
     * Clear product caches (to be called when products are updated)
     */
    public function clearProductCache(): JsonResponse
    {
        try {
            // Clear all product-related cache
            Cache::flush(); // Alternative: use more specific cache clearing
            
            return response()->json([
                'success' => true,
                'status' => 200,
                'message' => 'Product cache cleared successfully',
            ], 200);
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'status' => 500,
                'message' => 'Failed to clear cache: ' . $e->getMessage(),
            ], 500);
        }
    }
}
